#!/usr/bin/bash

# Only tested for:
# Lenovo Yoga Slim 7i Aura Edition
# KDE Plasma (Wayland) in OpenSUSE Tumbleweed

PATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin"

BATTERY_STATUS_PATH="/sys/class/power_supply/BAT0/status"
KBD_BRIGHTNESS_FILE="/sys/class/leds/platform::kbd_backlight/brightness"
SLEEPING=0
WIFI_ENABLED=
BT_ENABLED=
KB_BACKLIGHT=
STANDBY_DRAIN_START=-1

# the amount of time to wait in idle before entering hibernation
# set this to zero (0) to disable this entirely.
HIBERNATE_TIMER_MINS=30

# Since this script doesn't modify the filesystem (afaik), the -e option is omitted.
# This is because there are some quite crucial commands such as "kill" that return harmless error codes,
# that would otherwise cause this script to exit and maroon itself in a SIGSTOP state that I don't want.
#
# It's also used in a lot of my functions to avoid the use of subshells, which don't affect the parent environment
set -uo pipefail

if [ "$EUID" -eq 0 ]; then
	echo "You shouldn't run this as root." >&2
	exit 1
fi

# Writes to stderr when program isn't available and exits
# Writes to /dev/null when program is available
{ which rfkill && which brightnessctl && which loginctl && which kscreen-doctor || exit 1; } >/dev/null

if [ ! -f "$KBD_BRIGHTNESS_FILE" ] ; then
	echo Could not find the keyboard brightness file.
	exit 1
fi

echo_if_debug() {
	[ "${DEBUG:-0}" -eq 1 ] && echo "$1"
	return 0
}

_is_radio_blocked() {
	if rfkill list "$1" | grep -q "Soft blocked: no"; then
		echo "enabled"
	else
		echo "disabled"
	fi
}

_KBD_BRIGHTNESS=
_set_backlight() {
	# brightnessctl is needed to change the backlight w/o root
	declare -g _KBD_BRIGHTNESS
	_KBD_BRIGHTNESS="$1"
	brightnessctl s "$1" -d "platform::kbd_backlight" >/dev/null
}

_get_backlight() {
	declare -g "_KBD_BRIGHTNESS"
	# Sometimes works, sometimes doesn't.
	# Guaranteed to just output `0` after the first read, so cache it instead
	# Now let's hope it doesn't output `0` on the first read...
	if [ "$_KBD_BRIGHTNESS" == "" ]; then
		out=$(brightnessctl g -d platform::kbd_backlight)
		declare -g _KBD_BRIGHTNESS
		_KBD_BRIGHTNESS="$out"
	fi
	echo "$_KBD_BRIGHTNESS"
}

get_pname() {
	if [ "$1" = "" ] || [ "$1" -lt 1 ] || [ "$1" -gt 4194304 ]
	then return
	fi
	ps -p "$1" -o comm=
}

collect_ancestors() {
	pid=$BASHPID
	while [ "$pid" -ne 1 ]; do
		echo "$pid"
		pid=$(ps -o ppid= -p "$pid" | tr -d ' ')
	done
}

get_descendants() {
    local parent=$1
    for child in $(ps -o pid= --ppid "$parent"); do
        echo "$child"
        get_descendants "$child"
    done
}

send_sig() {
	# Rule 1: Do not stop ancestors
	# Rule 2: Do not stop non-user processes
	# Rule 3: Do not stop children processes of $BASHPID

	# Collect all processes at the beginning.
	# This is so we don't accidentally stop new children we create.
	user_procs=$(ps -u "$USER" -o pid=)
	declare -ag KEEP_PID

	echo "$user_procs" | while read -r pid; do
		#pname=$(get_pname "$pid")
		if [[ ! " ${KEEP_PID[*]} " =~ [[:space:]]${pid}[[:space:]] ]]; then
			echo "$pid"
			kill -"$1" "$pid"
		fi
	done
}

is_discharging() {
	status=$(cat "$BATTERY_STATUS_PATH")
	[ "$status" = "Discharging" ]
}

update_standby_drain_start() {
	declare -g STANDBY_DRAIN_START

	if [ "${1:-}" = "start" ]; then
		echo_if_debug "update_standby_drain_start: if start"
		# This branch is the same as the second one EXCEPT it overwrites
		# the amount of time elapsed. If we ran this branch all the time, the variable would be useless.
		if is_discharging
		then STANDBY_DRAIN_START="$SECONDS"
		else STANDBY_DRAIN_START=-1
		fi
	else
		echo_if_debug "update_standby_drain_start: else"
		# This second piece of code is run during the hibernation sleep loop.
		# It is meant to update the drain status AFTER sleep has been entered.
		# However, it won't overwrite a positive value if already discharging, therefore keeping score.
		if ! is_discharging
		then STANDBY_DRAIN_START=-1
		elif [ "$STANDBY_DRAIN_START" -eq -1 ]
		then STANDBY_DRAIN_START="$SECONDS"
		fi
	fi
}

_suspend() {
	# Check if already in custom sleep state
	if [ "$SLEEPING" -eq 1 ]; then
		return 0
	fi

	echo_if_debug "Entered sleep"

	declare -g SLEEPING
	declare -g KB_BACKLIGHT
	declare -g WIFI_ENABLED
	declare -g BT_ENABLED
	declare -g STANDBY_DRAIN_START

	update_standby_drain_start start

	SLEEPING=1
	KB_BACKLIGHT=$(_get_backlight)
	WIFI_ENABLED=$(_is_radio_blocked wifi)
	BT_ENABLED=$(_is_radio_blocked bluetooth)

	rfkill block wifi
	rfkill block bluetooth
	_set_backlight 0
	kscreen-doctor --dpms off
	loginctl lock-session

	sleep 2
	# Rule 1: Do not stop ancestors
	# Rule 2: Do not stop non-user processes
	# Rule 3: Do not stop children processes of $BASHPID

	declare -ag KEEP_PID
	KEEP_PID=()
	for child in $(collect_ancestors) 1 $(get_descendants $BASHPID); do
		KEEP_PID+=("$child")
	done

	#send_sig STOP
}

unblock_if_blocked_prev() {
	if [ "$1" == "enabled" ]; then
		rfkill unblock "$2"
	fi
}

_wake() {
	declare -g SLEEPING
	declare -g WIFI_ENABLED
	declare -g BT_ENABLED
	declare -g KB_BACKLIGHT
	declare -ag KEEP_PID

	if [ "$SLEEPING" -eq 0 ]; then
		return 0
	fi

	SLEEPING=0

	echo_if_debug "Entered wake"

	# Wake everything up first
	#send_sig CONT
	KEEP_PID=()

	sleep 1

	kscreen-doctor --dpms on

	unblock_if_blocked_prev "$WIFI_ENABLED" "wifi"
	unblock_if_blocked_prev "$BT_ENABLED" "bluetooth"

	# Restore keyboard backlight
	if [ ! "$KB_BACKLIGHT" = "" ]; then
		_set_backlight "$KB_BACKLIGHT"
	fi
}

# can_hibernate() : returns whether the computer has been in standby for long enough to hibernate
# params: none
# returns: an exit status of 0 if it can hibernate or 1 if it shouldn't hibernate
can_hibernate() {
	declare -g SLEEPING
	declare -g HIBERNATE_TIMER_MINS
	declare -g STANDBY_DRAIN_START
	if [ "$SLEEPING" -ne 1 ] || [ "$HIBERNATE_TIMER_MINS" -eq 0 ] || [ "$STANDBY_DRAIN_START" -eq -1 ] ; then
		return 1
	fi
	
	elapsed_mins=$(("($SECONDS - $STANDBY_DRAIN_START) / 60"))
	[ "$elapsed_mins" -ge "$HIBERNATE_TIMER_MINS" ]
	status=$?
	return $status
}

# wait_hibernate() : put the computer to hibernation if can_hibernate() says so, and updates drain variable.
# params: none
# returns: none
wait_hibernate() {
	declare -g STANDBY_DRAIN_START
	declare -g SLEEPING

	echo_if_debug "wait_hibernate: time=$SECONDS, DRAIN_START=$STANDBY_DRAIN_START"

	if [ "$SLEEPING" -eq 1 ] ; then
		update_standby_drain_start
	fi

	if can_hibernate
	then
		echo_if_debug "Entering hibernation."
		systemctl hibernate
		_wake
		echo_if_debug "Left hibernation at time=$SECONDS."
	fi
}

timer() {
	while true; do
		echo "TICK"
		sleep 10
	done
}

listen_for_events() {
	dbus-monitor --system "type='signal',path=/org/freedesktop/UPower" 2>&1 | grep --line-buffered -A1 LidIsClosed
}

# Begin listening for lid events
{
	listen_for_events &
	timer &
	wait
} | while read -r line
do
    case "$line" in
        *"boolean true"*) _suspend;;
        *"boolean false"*) _wake;;
        *"TICK"*) wait_hibernate;;
    esac
done
